{{for|subroutine-oriented programming|procedural programming}}
{{Programming paradigms}}

In [[computer science]], '''functional programming''' is a [[programming paradigm]] that treats [[computation]] as the evaluation of [[function (mathematics)|mathematical function]]s and avoids [[program state|state]] and [[immutable object|mutable]] data. It emphasizes the application of functions, in contrast to the [[imperative programming]] style, which emphasizes changes in state.<ref name="hudak1989">{{ cite journal | last = Hudak | first = Paul | authorlink = Paul Hudak | title = Conception, evolution, and application of functional programming languages | journal = [[Association for Computing Machinery|ACM]] Computing Surveys|volume=21|issue=3 | pages = 359–411 | month = September | year = 1989 | url = http://www.cs.berkeley.edu/~jcondit/pl-prelim/hudak89functional.pdf|format=PDF|doi=10.1145/72551.72554 }}</ref> Functional programming has its roots in [[lambda calculus]], a [[formal system]] developed in the 1930s to investigate function definition, function application, and [[recursion]]. Many functional [[programming language]]s can be viewed as elaborations on the [[lambda calculus]].<ref name="hudak1989"/>

In practice, the difference between a mathematical function and the notion of a "function" used in imperative programming is that imperative functions can have [[side effect (computer science)|side effects]], changing the value of program [[program state|state]]. Because of this they lack [[referential transparency (computer science)|referential transparency]], i.e. the same language expression can result in different values at different times depending on the state of the executing program. Conversely, in functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function ''f'' twice with the same value for an argument ''x'' will produce the same result ''f(x)'' both times. Eliminating side effects can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming.<ref name="hudak1989"/>

Functional programming languages, especially [[purely functional]] ones, have largely been emphasized in [[academic|academia]] rather than in commercial software development. However, prominent functional programming languages such as [[Scheme (programming language)|Scheme]],<ref name="clinger1987"/><ref name="hartheimer1987"/><ref name="kidd2007"/><ref name="cleis2006"/> [[Clojure]], [[Racket (programming language)|Racket]],<ref name="racket-video-games"/> [[Erlang (programming language)|Erlang]],<ref name="erlang-faq"/><ref name="armstrong2007"/><ref name="larson2009"/> [[Objective Caml]],<ref name="minksy2008"/><ref name="leroy2007"/> [[Haskell (programming language)|Haskell]]<ref name="haskell-industry"/><ref name="hudak2007"/> and [[F Sharp (programming language)|F#]]<ref name='quantFSharp'>{{ cite conference | last = Mansell | first = Howard | title = Quantitative Finance in F# | url = http://cufp.galois.com/2008/abstracts.html#MansellHoward | year = 2008 | conference = CUFP 2008 | accessdate = 2009-08-29 }}</ref><ref name='businessAppsFSharp'>{{ cite conference | last = Peake | first = Alex | title = The First Substantial Line of Business Application in F# | url = http://cufp.galois.com/2009/abstracts.html#AlexPeakeAdamGranicz | year = 2009 | conference = CUFP 2009 | accessdate = 2009-08-29 }}</ref> have been used in industrial and commercial applications by a wide variety of organizations. Functional programming is also supported in some [[domain-specific programming language]]s like [[R (programming language)|R]] (statistics),<ref name="useR"/><ref name="Chambers"/> [[Mathematica]] (symbolic math),<ref name="Amath-CO"/> [[J (programming language)|J]] and [[K (programming language)|K]] (financial analysis){{Citation needed| date = August 2009}} and [[XQuery]]/[[XSLT]] ([[XML]]).<ref name="Novatchev"/><ref name="Mertz"/> Widespread domain-specific declarative languages like [[SQL]] and [[Lex programming tool|Lex]]/[[Yacc]] use some elements of functional programming, especially in eschewing mutable values.<ref name="Chamberlin_Boyce"/> [[Spreadsheet]]s can also be viewed as functional programming languages.<ref name="excel"/>

Programming in a functional style can also be accomplished in languages that aren't specifically designed for functional programming. For example, the imperative [[Perl (programming language)|Perl]] programming language has been the subject of a book describing how to apply functional programming concepts.<ref>{{ cite book | last = Dominus | first = Mark J. | authorlink = Mark Jason Dominus | title = [[Higher-Order Perl]] |publisher=[[Morgan Kaufmann]] | year = 2005 |isbn = 1558607013 }}</ref>

== History ==

[[Lambda calculus]] provides a theoretical framework for describing functions and their evaluation. Although it is a mathematical abstraction rather than a programming language, it forms the basis of almost all functional programming languages today. An equivalent theoretical formulation, [[combinatory logic]], is commonly perceived as more abstract than lambda calculus and preceded it in invention. It is used in some esoteric languages including [[Unlambda]]. Combinatory logic and lambda calculus were both originally developed to achieve a clearer approach to the [[foundations of mathematics]].<ref>{{ cite book | last = Curry | first = Haskell Brooks |coauthors = Robert Feys and Craig, William | title = Combinatory Logic. Volume I |publisher=North-Holland Publishing Company |location = Amsterdam | year = 1958 }}</ref>

An early functional flavored language was [[Lisp (programming language)|Lisp]], developed by [[John McCarthy (computer scientist)|John McCarthy]] while at [[Massachusetts Institute of Technology|MIT]] for the [[IBM 700/7000 series#Scientific Architecture|IBM 700/7000 series]] scientific computers in the late 1950s.<ref>{{ cite journal | first = John | last = McCarthy | authorlink = John McCarthy (computer scientist) | title = History of Lisp | journal = In [[Association for Computing Machinery|ACM]] SIGPLAN History of Programming Languages Conference | pages = 217–223 | month = June | year = 1978 | url = http://citeseer.ist.psu.edu/mccarthy78history.html|doi=10.1145/800025.808387 }}</ref> Lisp introduced many features now found in functional languages, though Lisp is technically a multi-paradigm language. [[Scheme (programming language)|Scheme]] and [[Dylan programming language|Dylan]] were later attempts to simplify and improve Lisp.

[[Information Processing Language]] (IPL) is sometimes cited as the first computer-based functional programming language.<ref>The memoir of [[Herbert Simon]] (1991), ''Models of My Life'' pp.189-190 ISBN 0-465-04640-1 claims that he, Al Newell, and Cliff Shaw are "commonly adjudged to be the parents of [the] artificial intelligence [field]", for writing [[Logic Theorist]], a program which proved theorems from ''[[Principia Mathematica]]'' automatically. In order to accomplish this, they had to invent a language and a paradigm which, which viewed retrospectively, embeds functional programming.</ref> It is an assembly-style language for manipulating lists of symbols. It does have a notion of "generator", which amounts to a function accepting a function as an argument, and, since it is an assembly-level language, code can be used as data, so IPL can be regarded as having higher-order functions. However, it relies heavily on mutating list structure and similar imperative features.

[[Kenneth E. Iverson]] developed [[APL (programming language)|APL]] in the early 1960s, described in his 1962 book ''A Programming Language'' (ISBN 9780471430148). APL was the primary influence on [[John Backus]]'s [[FP (programming language)|FP]]. In the early 1990s, Iverson and [[Roger Hui]] created [[J (programming language)|J]]. In the mid 1990s, [[Arthur Whitney (computer scientist)|Arthur Whitney]], who had previously worked with Iverson, created [[K (programming language)|K]], which is used commercially in financial industries.

[[John Backus]] presented [[FP (programming language)|FP]] in his 1977 [[Turing Award]] lecture "Can Programming Be Liberated From the von Neumann Style? A Functional Style and its Algebra of Programs".<ref>http://www.stanford.edu/class/cs242/readings/backus.pdf</ref> He defines functional programs as being built up in a hierarchical way by means of "combining forms" that allow an "algebra of programs"; in modern language, this means that functional programs follow the [[principle of compositionality]]. Backus's paper popularized research into functional programming, though it emphasized [[function-level programming]] rather than the lambda-calculus style which has come to be associated with functional programming.

In the 1970s [[ML (programming language)|ML]] was created by [[Robin Milner]] at the [[University of Edinburgh]], and [[David Turner (computer scientist)|David Turner]] developed initially the language [[SASL (programming language)|SASL]] at the [[University of St. Andrews]] and later the language [[Miranda (programming language)|Miranda]] at the [[University of Kent]]. ML eventually developed into several dialects, the most common of which are now [[Objective Caml]] and [[Standard ML]]. Also in the 1970s, the development of [[Scheme (programming language)|Scheme]] (a partly functional dialect of Lisp), as described in the influential [[Lambda Papers]] and the 1985 textbook ''[[Structure and Interpretation of Computer Programs]]'', brought awareness of the power of functional programming to the wider programming-languages community.

In the 1980s, [[Per Martin-Löf]] developed [[intuitionistic type theory]] (also called ''Constructive'' type theory), which associated functional programs with [[constructive proof]]s of arbitrarily complex mathematical propositions expressed as [[dependent type]]s. This led to powerful new approaches to [[interactive theorem proving]] and has influenced the development of many subsequent functional programming languages.

The [[Haskell (programming language)|Haskell language]] began with a consensus in 1987 to form an [[open standard]] for functional programming research; implementation releases have been ongoing since 1990.

== Concepts ==

A number of concepts and paradigms are specific to functional programming, and generally foreign to [[imperative programming]] (including [[object oriented programming]]). However, programming languages are often hybrids of several programming paradigms so programmers using "mostly imperative" languages may have utilized some of these concepts.<ref>{{ cite web | url = http://www.byte.com/art/9408/sec11/art1.htm | title = Functional Programming Comes of Age | author = Dick Pountain | work=BYTE.com (August 1994) | accessdate = August 31, 2006 }}</ref>

=== First-class and higher-order functions ===
{{main|first-class function|higher-order function}}

[[Higher-order function]]s are functions that can either take other functions as arguments or return them as results (the [[differential operator]] <math>d/dx</math> that produces the [[derivative]] of a function <math>f</math> is an example of this in calculus).

Higher-order functions are closely related to [[first-class function]]s, in that higher-order functions and first-class functions both allow functions as arguments and results of other functions. The distinction between the two is subtle: "higher-order" describes a mathematical concept of functions that operate on other functions, while "first-class" is a computer science term that describes programming language entities that have no restriction on their use (thus first-class functions can appear anywhere in the program that other first-class entities like numbers can, including as arguments to other functions and as their return values).

Higher-order functions enable [[partial application]] or [[currying]], a technique in which a function is applied to its arguments one at a time, with each application returning a new function that accepts the next argument. This allows one to succinctly express, for example, the successor function as the addition operator partially applied to the natural number one.

=== Pure functions ===

[[Purely functional]] functions (or expressions) have no memory or I/O [[side effect (computer science)|side effects]]. This means that pure functions have several useful properties, many of which can be used to optimize the code:

* If the result of a pure expression is not used, it can be removed without affecting other expressions.
* If a pure function is called with parameters that cause no side-effects, the result is constant with respect to that parameter list (sometimes called [[referential transparency (computer science)|referential transparency]]), i.e. if the pure function is again called with the same parameters, the same result will be returned (this can enable caching optimizations such as [[memoization]]).
* If there is no data dependency between two pure expressions, then their order can be reversed, or they can be performed in [[parallelization|parallel]] and they cannot interfere with one another (in other terms, the evaluation of any pure expression is [[thread-safe]]).
* If the entire language does not allow side-effects, then any evaluation strategy can be used; this gives the compiler freedom to reorder or combine the evaluation of expressions in a program (for example, using [[deforestation (computer science)|deforestation]]).

While most compilers for imperative programming languages detect pure functions, and perform common-subexpression elimination for pure function calls, they cannot always do this for pre-compiled libraries, which generally do not expose this information, thus preventing optimizations that involve those external functions. Some compilers, such as [[GNU Compiler Collection|gcc]], add extra keywords for a programmer to explicitly mark external functions as pure, to enable such optimizations. [[Fortran 95]] allows functions to be designated "pure".

=== Recursion ===
{{Main|recursion (computer science)}}

[[Iteration]] (looping) in functional languages is usually accomplished via [[recursion]]. [[recursion (computer science)|Recursive function]]s invoke themselves, allowing an operation to be performed over and over. Recursion may require maintaining a stack, but [[tail recursion]] can be recognized and optimized by a compiler into the same code used to implement iteration in imperative languages. The [[Scheme (programming language)|Scheme]] language standard requires implementations to recognize and optimize tail recursion. Tail recursion optimization can be implemented by transforming the program into [[continuation passing style]] during compiling, among other approaches.

Common patterns of recursion can be factored out using higher order functions, with [[catamorphism]]s and [[anamorphism]]s (or "folds" and "unfolds") being the most obvious examples. Such higher order functions play a role analogous to built-in control structures such as [[Program loops|loops]] in [[imperative languages]].

Most general purpose functional programming languages allow unrestricted recursion and are [[Turing complete]], which makes the [[halting problem]] [[undecidable problem|undecidable]], can cause unsoundness of [[equational reasoning]], and generally requires the introduction of [[inconsistency]] into the logic expressed by the language's [[type system]]. Some special purpose languages such as [[Coq]] allow only [[well-founded]] recursion and are [[strongly normalizing]] (nonterminating computations can be expressed only with infinite streams of values called [[codata]]). As a consequence, these languages fail to be Turing complete and expressing certain functions in them is impossible, but they can still express a wide class of interesting computations while avoiding the problems introduced by unrestricted recursion. Functional programming limited to well-founded recursion with a few other constraints is called [[total functional programming]]. See Turner 2004 for more discussion.<ref name=totalfp>{{ cite journal | last = Turner | first = D.A.|author-link=David Turner (computer scientist) | title = Total Functional Programming | journal = Journal of Universal Computer Science|volume=10| date = 2004-07-28 | pages = 751–768 | url = http://www.jucs.org/jucs_10_7/total_functional_programming|doi=10.3217/jucs-010-07-0751|issue=7|postscript=<!--None--> }}</ref>

=== Strict versus non-strict evaluation ===
{{Main|Evaluation strategy}}

Functional languages can be categorized by whether they use ''strict (eager)'' or ''non-strict (lazy)'' evaluation, concepts that refer to how function arguments are processed when an expression is being evaluated. The technical difference is in the [[denotational semantics]] of expressions containing failing or divergent computations. Under strict evaluation, the evaluation of any term containing a failing subterm will itself fail. For example, the expression:

<!-- language? -->
 print length([2+1, 3*2, 1/0, 5-4])

will fail under strict evaluation because of the division by zero in the third element of the list. Under nonstrict evaluation, the length function will return the value 4, since evaluating it will not attempt to evaluate the terms making up the list. In brief, strict evaluation always fully evaluates function arguments before invoking the function. Non-strict evaluation does not evaluate function arguments unless their values are required to evaluate the function call itself.

The usual implementation strategy for non-strict evaluation in functional languages is [[graph reduction]].<ref>[http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm The Implementation of Functional Programming Languages. Simon Peyton Jones, published by Prentice Hall, 1987]</ref> Non-strict evaluation is used by default in several pure functional languages, including [[Miranda (programming language)|Miranda]], [[Clean (programming language)|Clean]] and [[Haskell (programming language)|Haskell]].

Hughes 1984 argues for non-strict evaluation as a mechanism for improving program modularity through [[separation of concerns]], by easing independent implementation of producers and consumers of data streams.<ref>{{ cite web | url = http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html | title = Why Functional Programming Matters | authorlink=John Hughes (computer scientist) | author = John Hughes }}</ref> Launchbury 1993 <!-- a cite arguing more strongly against lazy evaluation would be preferable here, if someone knows of one. --> describes some difficulties that lazy evaluation introduces, particularly in analyzing a program's storage requirements, and proposes an [[operational semantics]] to aid in such analysis.<ref name=launchbury1993>{{ cite web | url = http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2016 | author = John Launchbury | title = A Natural Semantics for Lazy Evaluation | year = 1993 }}</ref> Harper 2009 proposes including both strict and nonstrict evaluation in the same language, using the language's type system to distinguish them.<ref>{{ cite book | url = http://www.cs.cmu.edu/~rwh/plbook/book.pdf | title = Practical Foundations for Programming Languages | author = Robert W. Harper | authorlink=Robert_Harper_(computer_scientist) | year = 2009 }}</ref>

=== Type systems ===
<!-- expand this section!!! also split it into several sections -->

Especially since the development of [[Hindley–Milner type inference]] in the 1970s, functional programming languages have tended to use [[typed lambda calculus]], as opposed to the [[untyped lambda calculus]] used in Lisp and its variants (such as Scheme). The use of [[algebraic datatypes]] and [[pattern matching]] makes manipulation of complex data structures more convenient and expressive; the presence of strong compile-time type checking makes programs more reliable, while [[type inference]] frees the programmer from the need to manually declare types to the compiler.

Some research-oriented functional languages such as [[Coq]], [[Agda (theorem prover)|Agda]], [[Cayenne (programming language)|Cayenne]], and [[Epigram (programming language)|Epigram]] are based on [[intuitionistic type theory]], which allows types to depend on terms. Such types are called [[dependent type]]s. These type systems do not have decidable type inference and are difficult to understand and program with. But dependent types can express arbitrary propositions in [[predicate logic]]. Through the [[Curry–Howard isomorphism]], then, well-typed programs in these languages become a means of writing formal [[mathematical proof]]s from which a compiler can generate [[formal verification|certified code]]. While these languages are mainly of interest in academic research (including in [[formalized mathematics]]), they have begun to be used in engineering as well. [[Compcert]] is a [[compiler]] for a subset of the [[C (programming language)|C programming language]] that is written in Coq and formally verified.<ref>{{ cite web | url = http://compcert.inria.fr/doc/index.html | title = The Compcert verified compiler }}</ref>

A limited form of dependent types called [[generalized algebraic data type]]s (GADT's) can be implemented in a way that provides some of the benefits of dependently-typed programming while avoiding most of its inconvenience.<ref>{{ cite web | url = http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/ | title = Simple unification-based type inference for GADTs | author = Simon Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Geoffrey Washburn | work=ICFP 2006 | pages = 50–61 }}</ref> GADT's are available in the [[Glasgow Haskell Compiler]] and in [[Scala (programming language)|Scala]] (as "case classes"), and have been proposed as additions to other languages including Java and C#.<ref>{{ cite web | title = Generalized Algebraic Data Types and Object-Oriented Programming | author = Andrew Kennedy and Claudio Russo | work=OOPSLA | date = October 2005 | location = San Diego, California | url = http://research.microsoft.com/~akenn/generics/gadtoop.pdf }} [http://lambda-the-ultimate.org/node/1134 source of citation]</ref>

=== Functional programming in non-functional languages ===

It is possible to use a functional style of programming in languages that are not traditionally considered functional languages.<ref>{{ cite journal | last = Hartel | first = Pieter | coauthors = Henk Muller and Hugh Glaser | title = The Functional C experience | journal = The Journal of Functional Programming | volume=14 |issue=2 | pages = 129–135 | month = March | year = 2004 | url = http://www.ub.utwente.nl/webdocs/ctit/1/00000084.pdf |format=PDF| doi=10.1017/S0956796803004817}}; {{ cite web | title = Functional programming in Python, Part 3 | url = http://www-128.ibm.com/developerworks/linux/library/l-prog3.html | author = David Mertz | accessdate = 2006-09-17 | work=IBM developerWorks}}([http://www-128.ibm.com/developerworks/library/l-prog.html Part 1], [http://www-128.ibm.com/developerworks/library/l-prog2.html Part 2])</ref> Among imperative programming languages, the [[D (programming language)|D]] programming language's solid support for functional programming stands out. For example, D has a pure modifier to enforce functional purity. Only [[Fortran 95]] has something similar.<ref>{{ cite web | url = http://www.digitalmars.com/d/2.0/function.html#pure-functions | title = Functions&nbsp;— D Programming Language 2.0 |publisher=Digital Mars | date = | accessdate = 2011-06-20 }}</ref>

First class functions have slowly been added to mainstream languages. For example, in early 1994, support for lambda, filter, map, and reduce was added to [[Python (programming language)|Python]]. Then during the development of Python 3000, [[Guido van Rossum]] called for the removal of these features. So far, only the <code>reduce</code> function has been removed,<ref>{{ cite web | url = http://www.artima.com/weblogs/viewpost.jsp?thread=98196 | title = The fate of reduce() in Python 3000 |publisher=Artima.com | date = 2005-03-10  | accessdate = 2011-06-20 }}</ref> and it remains accessible via the <code>functools</code> standard library module.<ref>{{ cite web | url = http://docs.python.org/dev/library/functools.html#functools.reduce | title = functools — Higher order functions and operations on callable objects | publisher=Python Software Foundation | date = 2011-07-31 | accessdate = 2011-07-31}}</ref>  First class functions were also introduced in [[PHP]] 5.3, [[Visual Basic]] 9, [[C#(programming language)|C#]] 3.0, and [[C++0x]].

The [[Language Integrated Query]] (LINQ) feature, with its many incarnations, is an obvious and powerful use of functional programming in [[.NET Framework|.NET]].

In [[Java (programming language)|Java]], [[anonymous class]]es can sometimes be used to simulate [[Closure (computer science)|closure]]s;{{Citation needed| date = January 2009}} however, anonymous classes are not always proper replacements to [[Closure (computer science)|closure]]s because they have more limited capabilities.

Many [[object-oriented]] [[Design pattern (computer science)|design pattern]]s are expressible in functional programming terms: for example, the [[strategy pattern]] simply dictates use of a higher-order function, and the [[visitor (design pattern)|visitor]] pattern roughly corresponds to a [[catamorphism]], or [[fold (higher-order function)|fold]].

The benefits of immutable data can be seen even in imperative programs, so programmers often strive to make some data immutable even in imperative programs.<ref>{{ cite book | title = Effective Java | edition = Second Edition | first = Joshua | last = Bloch | pages = Item 15 }}</ref>

== Comparison to imperative programming ==

Functional programming is very different from [[imperative programming]]. The most significant differences stem from the fact that functional programming avoids [[side effect (computer science)|side effects]], which are used in imperative programming to implement state and I/O. Pure functional programming disallows side effects completely. Disallowing side effects provides for [[referential transparency (computer science)|referential transparency]], which makes it easier to verify, optimize, and parallelize programs, and easier to write automated tools to perform those tasks.

Higher-order functions are rarely used in older imperative programming. Where a traditional imperative program might use a loop to traverse a list, a functional program would use a different technique.  It would use a higher-order function that takes as arguments a function and a list.  The higher-order function would then apply the given function to each element of the given list and then return a new list with the results.

=== Simulating state ===

There are tasks (for example, maintaining a bank account balance) that often seem most naturally implemented with state. Pure functional programming performs these tasks, and I/O tasks such as accepting user input and printing to the screen, in a different way.

The pure functional programming language [[Haskell (programming language)|Haskell]] implements them using [[monad (functional programming)|monads]], derived from [[category theory]]. Monads are powerful and offer a way to abstract certain types of computational patterns, including (but not limited to) modeling of computations with mutable state (and other side effects such as I/O) in an imperative manner without losing purity. While existing monads may be easy to apply in a program, given appropriate templates and examples, many students find them difficult to understand conceptually, e.g., when asked to define new monads (which is sometimes needed for certain types of libraries).<ref>{{ cite web | last = Newbern | first = J. | title = All About Monads: A comprehensive guide to the theory and practice of monadic programming in Haskell | url = http://monads.haskell.cz/html/index.html/html/ | accessdate = 2008-02-14 }}</ref>
<!-- TO DO: Expand -->

Alternative methods such as [[Hoare logic]] and [[uniqueness type|uniqueness]] have been developed to track side effects in programs. Some modern research languages use [[effect system]]s to make explicit the presence of side effects.
<!-- TO DO: Expand -->

=== Efficiency issues ===
{{Original research|section| date = May 2009}}

Functional programming languages are typically less efficient in their use of [[central processing unit|CPU]] and memory than imperative languages such as [[C programing language|C]] and [[Pascal (programming language)|Pascal]].<ref>[[Lawrence Paulson|Lawrence C. Paulson]], ''ML for the Working Programmer''. Cambridge UP, 1996. ISBN 052156543X.</ref> <!-- Paulson mentions the reputation for inefficiency in Sec. 1.5; perhaps a more in-depth discussion could be found. --> For purely functional languages, the worst-case slowdown is logarithmic in the number of memory cells used, because mutable memory can be represented by a purely functional data structure with logarithmic access time (such as a balanced tree).{{Citation needed| date = February 2010}} However, such slowdowns are not universal. For programs that perform intensive numerical computations, functional languages such as [[Objective Caml]] and [[Clean (programming language)|Clean]] are only slightly slower than [[C (programming language)|C]].<ref>{{ cite web | url = http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=all&d=data&calc=calculate&gcc=on&clean=on&sbcl=on&ocaml=on&ghc=on&fsharp=on&hipe=on&mzscheme=on | title = Boxplot Summary &#124; Computer Language Benchmarks Game |publisher=Shootout.alioth.debian.org | date =  | accessdate = 2011-06-20 }}</ref> For programs that handle large [[matrix (mathematics)|matrices]] and multidimensional [[database]]s, [[array programming|array]] functional languages (such as [[J (programming language)|J]] and [[K (programming language)|K]]) were designed with speed optimization.

Immutability of data can, in many cases, lead to execution efficiency in allowing the compiler to make assumptions that are unsafe in an imperative language, thus increasing opportunities for [[inline expansion]].{{Citation needed| date = October 2008}}

[[Lazy evaluation]] may also speed up the program, even asymptotically, whereas it may slow it down at most by a constant factor (however, it may introduce memory leaks when used improperly). Launchbury 1993<ref name=launchbury1993/> discusses theoretical issues related to memory leaks from lazy evaluation, and O'Sullivan ''et al.'' 2008<ref>{{ cite web | url = http://book.realworldhaskell.org/read/profiling-and-optimization.html#x_eK1 | title = Chapter 25. Profiling and optimization |publisher=Book.realworldhaskell.org | date =  | accessdate = 2011-06-20 }}</ref> give some practical advice for analyzing and fixing them.

=== Coding styles ===

Imperative programs tend to emphasize the series of steps taken by a program in carrying out an action, while functional programs tend to emphasize the composition and arrangement of functions, often without specifying explicit ''steps''. A simple example illustrates this with two solutions to the same programming goal (calculating [[Fibonacci number]]s). The imperative example is in [[C++]].

<source lang="cpp">
// Fibonacci numbers, imperative style
int fibonacci(int iterations)
{
    int first = 0, second = 1; // seed values

    for (int i = 0; i < iterations; ++i) {
        int sum = first + second;
        first = second;
        second = sum;
    }

    return first;
}

std::cout << fibonacci(10) << "\n";
</source>

A functional version (in [[Haskell (programming language)|Haskell]]) has a different feel to it:

<source lang="haskell">
-- Fibonacci numbers, functional style

-- describe an infinite list based on the recurrence relation for Fibonacci numbers
fibRecurrence first second = first : fibRecurrence second (first + second)

-- describe fibonacci list as fibRecurrence with initial values 0 and 1
fibonacci = fibRecurrence 0 1

-- describe action to print the 10th element of the fibonacci list
main = print (fibonacci !! 10)
</source>

The imperative style describes the intermediate steps involved in calculating <code>fibonacci(N)</code>, and places those steps inside a [[Program loops|loop statement]]. In contrast, the functional implementation shown here states the mathematical [[recurrence relation]] that defines the entire Fibonacci sequence, then selects an element from the sequence (see also [[recursion (computer science)|recursion]]). This example relies on Haskell's [[lazy evaluation]] to create an "infinite" list of which only as much as needed (the first 10 elements in this case) will actually be computed. That computation happens when the runtime system carries out the action described by "main".

== Use in industry ==

Functional programming has long been popular in academia, but with few industrial applications.<ref name='programmingScala'>{{ cite book | first1 = Martin | last1 = Odersky | first2 = Lex | last2 = Spoon | first3 = Bill | last3 = Venners | date = December 13, 2010 | title = Programming in Scala: A Comprehensive Step-by-step Guide | publisher = [[Artima Inc]] | edition = 2nd | pages = 883/852 | isbn = 9780981531649 | url = http://www.artima.com/shop/programming_in_scala_2ed }}</ref>{{rp|page 11}} However, recently several prominent functional programming languages have been used in commercial or industrial systems. For example, the [[Erlang (programming language)|Erlang]] programming language, which was developed by the [[Sweden|Swedish]] company [[Ericsson]] in the late 1980s, was originally used to implement fault-tolerant telecommunications systems.<ref name="armstrong2007"/> It has since become popular for building a range of applications at companies such as [[T-Mobile]], [[Nortel]], and [[Facebook]].<ref name="erlang-faq"/><ref name="larson2009"/><ref>{{ cite conference | last = Piro | first = Christopher | title = Functional Programming at Facebook | url = http://cufp.galois.com/2009/abstracts.html#ChristopherPiroEugeneLetuchy | year = 2009 | conference = CUFP 2009 | accessdate = 2009-08-29 }}</ref> The [[Scheme (programming language)|Scheme]] dialect of [[Lisp (programming language)|Lisp]] was used as the basis for several applications on early [[Apple Macintosh]] computers,<ref name="clinger1987"/><ref name="hartheimer1987"/> and has more recently been applied to problems such as training [[software simulation|simulation software]]<ref name="kidd2007"/> and [[telescope]] control.<ref name="cleis2006"/> [[Objective Caml]], which was introduced in the mid 1990s, has seen commercial use in areas such as financial analysis,<ref name="minksy2008"/> [[software driver|driver]] verification, industrial [[robot]] programming, and static analysis of [[embedded software]].<ref name="leroy2007"/> [[Haskell (programming language)|Haskell]], although initially intended as a research language,<ref name="hudak2007"/> has also been applied by a range of companies, in areas such as aerospace systems, hardware design, and web programming.<ref name="haskell-industry"/><ref name="hudak2007"/>

Other functional programming languages that have seen use in industry include [[Scala (programming language)|Scala]],<ref>{{ cite conference | last = Momtahan | first = Lee | title = Scala at EDF Trading: Implementing a Domain-Specific Language for Derivative Pricing with Scala | url = http://cufp.galois.com/2009/abstracts.html#LeeMomtahan | year = 2009 | conference = CUFP 2009 | accessdate = 2009-08-29 }}</ref> [[F Sharp (programming language)|F#]],<ref name='quantFSharp'/><ref name='businessAppsFSharp'/> [[Lisp (programming language)|Lisp]],<ref>{{ cite web | last = Graham | first = Paul | title = Beating the Averages | url = http://www.paulgraham.com/avg.html | year = 2003 | accessdate = 2009-08-29 }}</ref> Standard ML,<ref>{{ cite conference | last = Sims | first = Steve | title = Building a Startup with Standard ML | url = http://cufp.galois.com/2006/slides/SteveSims.pdf | year = 2006 | conference = CUFP 2006 | accessdate = 2009-08-29 }}</ref><ref>{{ cite conference | last = Laurikari | first = Ville | title = Functional Programming in Communications Security. | url = http://cufp.galois.com/2007/abstracts.html#VilleLaurikari | year = 2007 | conference = CUFP 2007 | accessdate = 2009-08-29 }}</ref> and [[Clojure]].<ref>{{ cite web | url = http://www.infoq.com/news/2009/01/clojure_production | last = Lorimer | first = R. J. | title = Live Production Clojure Application Announced }}</ref>

== See also ==

* [[Comparison of programming paradigms]]
* [[Eager evaluation]]
* [[List of functional programming topics]]
* [[Nested function]]

== References ==

{{reflist|colwidth=30em|refs=
<ref name="clinger1987">{{ cite journal | last = Clinger | first = Will | title = MultiTasking and MacScheme | magazine = MacTech | volume = 3 | issue = 12 | year = 1987 | url = http://www.mactech.com/articles/mactech/Vol.03/03.12/Multitasking/index.html | accessdate = 2008-08-28 }}</ref><ref name="hartheimer1987">{{ cite journal | last = Hartheimer | first = Anne | title = Programming a Text Editor in MacScheme+Toolsmith | magazine = MacTech | volume = 3 | issue = 1 | year = 1987 | url = http://www.mactech.com/articles/mactech/Vol.03/03.1/SchemeWindows/index.html | accessdate = 2008-08-28 }}</ref><ref name="kidd2007">{{ cite conference | last = Kidd | first = Eric | url = http://cufp.galois.com/2007/abstracts.html#EricKidd | title = Terrorism Response Training in Scheme | conference = CUFP 2007 | accessdate = 2009-08-26 }}</ref><ref name="cleis2006">{{ cite conference | last = Cleis | first = Richard | url = http://cufp.galois.com/2006/abstracts.html#RichardCleis | title = Scheme in Space | conference = CUFP 2006 | accessdate = 2009-08-26 }}</ref><ref name="erlang-faq">{{ cite web | title = Who uses Erlang for product development? | work=Frequently asked questions about Erlang | url = http://www.erlang.org/faq/faq.html#AEN50 | accessdate = 2007-08-05 }}</ref><ref name="armstrong2007">{{ cite conference | last = Armstrong | first = Joe | title = A history of Erlang | conference = Third ACM SIGPLAN Conference on History of Programming Languages | location = San Diego, California | date = June 2007 | url = http://doi.acm.org/10.1145/1238844.1238850 | accessdate = 2009-08-29 }}</ref><ref name="larson2009">{{ cite journal | last = Larson | first = Jim | title = Erlang for concurrent programming | journal = Communications of the ACM | volume= 52 | issue= 3 | date = March 2009 | url = http://doi.acm.org/10.1145/1467247.1467263 | accessdate = 2009-08-29 | doi=10.1145/1467247.1467263 | page=48 }}</ref><ref name="minksy2008">{{ cite journal | last = Minsky | first = Yaron | last2 = Weeks | first2 = Stephen | title = Caml Trading&nbsp;— experiences with functional programming on Wall Street | journal = Journal of Functional Programming | volume = 18 | issue = 4 | pages = 553–564 | publisher = Cambridge University Press | location = | month = July | year = 2008 | url = http://journals.cambridge.org/action/displayAbstract?aid=1899164 | doi = 10.1017/S095679680800676X | accessdate = 2008-08-27 }}</ref><ref name="leroy2007">{{ cite conference | last = Leroy | first = Xavier | title = Some uses of Caml in Industry | url = http://cufp.galois.com/2007/slides/XavierLeroy.pdf | conference = CUFP 2007 | accessdate = 2009-08-26 }}</ref><ref name="haskell-industry">{{ cite web | title = Haskell in industry | work = Haskell Wiki | url = http://www.haskell.org/haskellwiki/Haskell_in_industry | accessdate = 2009-08-26 | quote=Haskell has a diverse range of use commercially, from aerospace and defense, to finance, to web startups, hardware design firms and lawnmower manufacturers. }}</ref><ref name="racket-video-games">{{cite web | title = State-Based Scripting in Uncharted 2 | url = http://www.gameenginebook.com/gdc09-statescripting-uncharted2.pdf | accessdate = 2011-08-08 }}</ref><ref name="hudak2007">{{ cite conference | last = Hudak | first = Paul | coauthors = Hughes, J., Jones, S. P., and Wadler, P. | authorlink=Paul Hudak | title = A history of Haskell: being lazy with class | conference = Third ACM SIGPLAN Conference on History of Programming Languages | location = San Diego, California| date = June 2007 | url = http://doi.acm.org/10.1145/1238844.1238856 | accessdate = 2009-08-29 }}</ref><ref name="useR">{{ cite web | url = http://www.r-project.org/useR-2006/program.html | title = The useR! 2006 conference schedule includes papers on the commercial use of R |publisher=R-project.org | date = 2006-06-08  | accessdate = 2011-06-20 }}</ref><ref name="Chambers">{{ cite book | last = Chambers | first = John M. | authorlink=John Chambers (programmer) | title = Programming with Data: A Guide to the S Language | publisher=Springer Verlag | year = 1998 | pages = 67–70 | isbn = 978-0387985039 }}</ref><ref name="Amath-CO">{{ cite web | author = Department of Applied Math, University of Colorado | title = Functional vs. Procedural Programming Language | url = http://amath.colorado.edu/computing/mmm/funcproc.html | accessdate = 2006-08-28 }}</ref><ref name="Novatchev">{{ cite web | url = http://www.topxml.com/xsl/articles/fp/ | author = Dimitre Novatchev | title = The Functional Programming Language XSLT&nbsp;— A proof through examples | accessdate = May 27, 2006 | work=TopXML }}</ref><ref name="Mertz">{{ cite web | url = http://gnosis.cx/publish/programming/xml_models_fp.html | author = David Mertz | title = XML Programming Paradigms (part four): Functional Programming approached to XML processing | accessdate = May 27, 2006 | work=IBM developerWorks }}</ref><ref name="Chamberlin_Boyce">{{ cite journal | title = SEQUEL: A structured English query language | author = [[Donald D. Chamberlin]] and [[Raymond F. Boyce]] | journal = Proceedings of the 1974 ACM SIGFIDET | pages = 249–264 | year = 1974 }}</ref><ref name="excel">{{ cite web | title = Improving the world's most popular functional language: user-defined functions in Excel | author = [[Simon Peyton Jones]], [[Margaret Burnett]], [[Alan Blackwell]] | url = http://research.microsoft.com/~simonpj/papers/excel/index.htm | month = March | year = 2003 }}</ref>
}}

== Further reading ==

* {{ cite book|last1=Abelson|first1=Hal|authorlink1=Hal Abelson|last2=Sussman|first2=Gerald Jay|authorlink2=Gerald Jay Sussman | title = [[Structure and Interpretation of Computer Programs]] | url = http://mitpress.mit.edu/sicp/ | year = 1985|publisher=MIT Press}}
* Cousineau, Guy and Michel Mauny. ''The Functional Approach to Programming''. Cambridge, UK: [[Cambridge University Press]], 1998.
* Curry, Haskell Brooks and Feys, Robert and Craig, William. ''Combinatory Logic''. Volume I. North-Holland Publishing Company, Amsterdam, 1958.
* {{ cite book | last1 = Curry | first1 = Haskell B. | first2 = J. Roger | last2 = Hindley | first3 = Jonathan P. | last3 = Seldin | authorlink1 = Haskell Curry | authorlink2 = J. Roger Hindley | authorlink3 = Jonathan P. Seldin | title = Combinatory Logic | volume = Vol. II | year = 1972 | publisher = North Holland | location = Amsterdam | isbn = 0-7204-2208-6 }}
* [[Mark Jason Dominus|Dominus, Mark Jason]]. ''[[Higher-Order Perl]]''. [[Morgan Kaufmann]]. 2005.
* {{ cite book|last1=Felleisen|first1=Matthias|last2=Findler|first2=Robert|last3=Flatt|first3=Matthew|first4=Shriram |last4=Krishnamurthi | title = [[How to Design Programs]] | url = http://www.htdp.org | year = 2001|publisher=MIT Press}}
* Graham, Paul. ''ANSI Common LISP''. Englewood Cliffs, New Jersey: [[Prentice Hall]], 1996.
* MacLennan, Bruce J. ''Functional Programming: Practice and Theory''. Addison-Wesley, 1990.
* {{ cite book|last1=O'Sullivan|first1=Brian|last2=Stewart|first2=John|last3=Goerzen|first3=Don | title = Real World Haskell | url = http://book.realworldhaskell.org/read/ | year = 2008|publisher=O'Reilly}}
* Pratt, Terrence, W. and Marvin V. Zelkowitz. ''Programming Languages: Design and Implementation''. 3rd ed. Englewood Cliffs, New Jersey: [[Prentice Hall]], 1996.
* Salus, Peter H. ''Functional and Logic Programming Languages''. Vol. 4 of Handbook of Programming Languages. Indianapolis, Indiana: [[Macmillan Technical Publishing]], 1998.
* Thompson, Simon. ''Haskell: The Craft of Functional Programming''. Harlow, England: [[Addison-Wesley Longman Limited]], 1996.

== External links ==
* [http://www.defmacro.org/ramblings/fp.html Functional Programming for the Rest of Us] An introduction by Slava Akhmechet
* ''Functional programming in Python'' (by David Mertz): [http://gnosis.cx/publish/programming/charming_python_13.html part 1], [http://gnosis.cx/publish/programming/charming_python_16.html part 2], [http://gnosis.cx/publish/programming/charming_python_19.html part 3]

{{Programming language}}

{{DEFAULTSORT:Functional Programming}}
[[Category:Programming paradigms]]
[[Category:Functional programming| ]]
[[Category:Articles with example Python code]]

[[ar:برمجة وظيفية]]
[[bn:ফাংশনভিত্তিক প্রোগ্রামিং]]
[[bs:Funkcionalno programiranje]]
[[ca:Programació funcional]]
[[cs:Funkcionální programování]]
[[da:Funktionsprogrammering]]
[[de:Funktionale Programmierung]]
[[et:Funktsionaalne programmeerimine]]
[[el:Συναρτησιακός προγραμματισμός]]
[[es:Programación funcional]]
[[fa:برنامه‌نویسی تابعی]]
[[fr:Programmation fonctionnelle]]
[[gl:Programación funcional]]
[[ko:함수형 프로그래밍]]
[[hr:Funkcijsko programiranje]]
[[id:Pemrograman Fungsional]]
[[it:Programmazione funzionale]]
[[he:תכנות פונקציונלי]]
[[ms:Pengaturcaraan kefungsian]]
[[nl:Functioneel programmeren]]
[[ja:関数型言語]]
[[pl:Programowanie funkcyjne]]
[[pt:Programação funcional]]
[[ro:Programare funcțională]]
[[rue:Функціоналне проґрамованя]]
[[ru:Функциональное программирование]]
[[sk:Funkcionálne programovanie]]
[[sr:Функционално програмирање]]
[[sh:Funkcijsko programiranje]]
[[fi:Funktionaalinen ohjelmointi]]
[[sv:Funktionell programmering]]
[[ta:பணிமுறை நிரல் மொழி]]
[[tr:Fonksiyonel programlama]]
[[uk:Функційне програмування]]
[[vi:Lập trình hàm]]
[[zh:函數程式語言]]